{"ast":null,"code":"/*\n * This file is part of React-SearchKit.\n * Copyright (C) 2019 CERN.\n *\n * React-SearchKit is free software; you can redistribute it and/or modify it\n * under the terms of the MIT License; see LICENSE file for more details.\n */\nimport _isPlainObject from 'lodash/isPlainObject';\nimport _find from 'lodash/find';\n/** Default backend response serializer */\n\nexport class InvenioResponseSerializer {\n  constructor() {\n    this.serialize = payload => {\n      return {\n        // aggregations: this._serializeAggregations(payload.aggregations || {}),\n        hits: payload.hits.hits,\n        total: payload.hits.total\n      };\n    };\n  }\n\n  // _createAggregation(parentKeyName, buckets) {\n  //   let aggregations = {};\n  //   buckets.forEach(item => {\n  //     const nestedField = _find(\n  //       Object.keys(item),\n  //       key =>\n  //         _isPlainObject(item[key]) &&\n  //         'buckets' in item[key] &&\n  //         item[key].buckets.length\n  //     );\n  //     if (nestedField) {\n  //       const nestedAggregationPath = [nestedField, 'buckets'];\n  //       const nestedBuckets = this._extractFromPath(\n  //         item,\n  //         nestedAggregationPath\n  //       );\n  //       const newKeyName = ''.concat(parentKeyName, '.', item.key);\n  //       aggregations[item.key] = this._createAggregation(\n  //         ''.concat(newKeyName, '.', nestedField),\n  //         nestedBuckets\n  //       );\n  //       aggregations[item.key]['key'] = newKeyName;\n  //       aggregations[item.key]['name'] = item.key;\n  //       aggregations[item.key]['total'] = item.doc_count;\n  //       aggregations[item.key]['hasNestedField'] = nestedField;\n  //     } else {\n  //       const parentNestedField = parentKeyName.split('.').slice(-1);\n  //       aggregations[item.key] = {\n  //         hasNestedField: false,\n  //         name: item.key,\n  //         total: item.doc_count,\n  //         key: ''.concat(parentKeyName, '.', item.key),\n  //       };\n  //     }\n  //   }, this);\n  //   return aggregations;\n  // }\n  // _extractFromPath(aggregation, pathToExtract) {\n  //   return pathToExtract.reduce(\n  //     (obj, key) => (obj && obj[key] !== 'undefined' ? obj[key] : undefined),\n  //     aggregation\n  //   );\n  // }\n  _serializeAggregations(aggregationsResponse) {\n    const aggregations = {};\n    Object.keys(aggregationsResponse).forEach(aggregationName => {\n      aggregations[aggregationName] = {};\n\n      const mainBuckets = this._extractFromPath(aggregationsResponse[aggregationName], ['buckets']);\n\n      aggregations[aggregationName] = this._createAggregation(aggregationName, mainBuckets);\n    }, this);\n    return aggregations;\n  }\n  /**\n   * Return a serialized version of the API backend response for the app state `results`.\n   * @param {object} payload the backend response payload\n   */\n\n\n}","map":{"version":3,"sources":["/home/datio/workspace/react-searchkit/src/lib/api/contrib/invenio/InvenioResponseSerializer.js"],"names":["_isPlainObject","_find","InvenioResponseSerializer","serialize","payload","hits","total","_serializeAggregations","aggregationsResponse","aggregations","Object","keys","forEach","aggregationName","mainBuckets","_extractFromPath","_createAggregation"],"mappings":"AAAA;;;;;;;AAQA,OAAOA,cAAP,MAA2B,sBAA3B;AACA,OAAOC,KAAP,MAAkB,aAAlB;AAEA;;AACA,OAAO,MAAMC,yBAAN,CAAgC;AAAA;AAAA,SAsErCC,SAtEqC,GAsEzBC,OAAO,IAAI;AACrB,aAAO;AACL;AACAC,QAAAA,IAAI,EAAED,OAAO,CAACC,IAAR,CAAaA,IAFd;AAGLC,QAAAA,KAAK,EAAEF,OAAO,CAACC,IAAR,CAAaC;AAHf,OAAP;AAKD,KA5EoC;AAAA;;AACrC;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEAC,EAAAA,sBAAsB,CAACC,oBAAD,EAAuB;AAC3C,UAAMC,YAAY,GAAG,EAArB;AAEAC,IAAAA,MAAM,CAACC,IAAP,CAAYH,oBAAZ,EAAkCI,OAAlC,CAA0CC,eAAe,IAAI;AAC3DJ,MAAAA,YAAY,CAACI,eAAD,CAAZ,GAAgC,EAAhC;;AACA,YAAMC,WAAW,GAAG,KAAKC,gBAAL,CAClBP,oBAAoB,CAACK,eAAD,CADF,EAElB,CAAC,SAAD,CAFkB,CAApB;;AAIAJ,MAAAA,YAAY,CAACI,eAAD,CAAZ,GAAgC,KAAKG,kBAAL,CAC9BH,eAD8B,EAE9BC,WAF8B,CAAhC;AAID,KAVD,EAUG,IAVH;AAYA,WAAOL,YAAP;AACD;AAED;;;;;;AAlEqC","sourcesContent":["/*\n * This file is part of React-SearchKit.\n * Copyright (C) 2019 CERN.\n *\n * React-SearchKit is free software; you can redistribute it and/or modify it\n * under the terms of the MIT License; see LICENSE file for more details.\n */\n\nimport _isPlainObject from 'lodash/isPlainObject';\nimport _find from 'lodash/find';\n\n/** Default backend response serializer */\nexport class InvenioResponseSerializer {\n  // _createAggregation(parentKeyName, buckets) {\n  //   let aggregations = {};\n\n  //   buckets.forEach(item => {\n  //     const nestedField = _find(\n  //       Object.keys(item),\n  //       key =>\n  //         _isPlainObject(item[key]) &&\n  //         'buckets' in item[key] &&\n  //         item[key].buckets.length\n  //     );\n  //     if (nestedField) {\n  //       const nestedAggregationPath = [nestedField, 'buckets'];\n  //       const nestedBuckets = this._extractFromPath(\n  //         item,\n  //         nestedAggregationPath\n  //       );\n  //       const newKeyName = ''.concat(parentKeyName, '.', item.key);\n  //       aggregations[item.key] = this._createAggregation(\n  //         ''.concat(newKeyName, '.', nestedField),\n  //         nestedBuckets\n  //       );\n  //       aggregations[item.key]['key'] = newKeyName;\n  //       aggregations[item.key]['name'] = item.key;\n  //       aggregations[item.key]['total'] = item.doc_count;\n  //       aggregations[item.key]['hasNestedField'] = nestedField;\n  //     } else {\n  //       const parentNestedField = parentKeyName.split('.').slice(-1);\n  //       aggregations[item.key] = {\n  //         hasNestedField: false,\n  //         name: item.key,\n  //         total: item.doc_count,\n  //         key: ''.concat(parentKeyName, '.', item.key),\n  //       };\n  //     }\n  //   }, this);\n\n  //   return aggregations;\n  // }\n\n  // _extractFromPath(aggregation, pathToExtract) {\n  //   return pathToExtract.reduce(\n  //     (obj, key) => (obj && obj[key] !== 'undefined' ? obj[key] : undefined),\n  //     aggregation\n  //   );\n  // }\n\n  _serializeAggregations(aggregationsResponse) {\n    const aggregations = {};\n\n    Object.keys(aggregationsResponse).forEach(aggregationName => {\n      aggregations[aggregationName] = {};\n      const mainBuckets = this._extractFromPath(\n        aggregationsResponse[aggregationName],\n        ['buckets']\n      );\n      aggregations[aggregationName] = this._createAggregation(\n        aggregationName,\n        mainBuckets\n      );\n    }, this);\n\n    return aggregations;\n  }\n\n  /**\n   * Return a serialized version of the API backend response for the app state `results`.\n   * @param {object} payload the backend response payload\n   */\n  serialize = payload => {\n    return {\n      // aggregations: this._serializeAggregations(payload.aggregations || {}),\n      hits: payload.hits.hits,\n      total: payload.hits.total,\n    };\n  };\n}\n"]},"metadata":{},"sourceType":"module"}