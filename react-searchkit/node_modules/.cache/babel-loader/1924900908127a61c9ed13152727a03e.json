{"ast":null,"code":"/*\n * This file is part of React-SearchKit.\n * Copyright (C) 2019 CERN.\n *\n * React-SearchKit is free software; you can redistribute it and/or modify it\n * under the terms of the MIT License; see LICENSE file for more details.\n */\nimport Qs from 'qs';\n/** Default backend request serializer */\n\nexport class InvenioRequestSerializer {\n  constructor() {\n    this.serialize = stateQuery => {\n      const queryString = stateQuery.queryString,\n            sortBy = stateQuery.sortBy,\n            sortOrder = stateQuery.sortOrder,\n            page = stateQuery.page,\n            size = stateQuery.size,\n            aggregations = stateQuery.aggregations;\n      const getParams = {};\n\n      if (queryString !== null) {\n        getParams['q'] = queryString;\n      }\n\n      if (sortBy !== null) {\n        getParams['sort'] = sortBy;\n\n        if (sortOrder !== null) {\n          getParams['sort'] = sortOrder === 'desc' ? \"-\".concat(sortBy) : sortBy;\n        }\n      }\n\n      if (page > 0) {\n        getParams['page'] = page;\n      }\n\n      if (size > 0) {\n        getParams['size'] = size;\n      }\n\n      this._addAggregations(getParams, aggregations);\n\n      return Qs.stringify(getParams, {\n        arrayFormat: 'repeat'\n      });\n    };\n  }\n\n  _addAggregations(getParams, aggregations) {\n    aggregations.forEach(aggregation => {\n      const rootKey = Object.keys(aggregation)[0];\n      /**\n       * The selection represent any one of the aggregation values clicked at any level of depth.\n       * Its value is the whole path e.g. for Type -> Publication -> (Subtype)Article\n       * the value will be type.publication.subtype.article from which the array will be created\n       * @type {string[]}\n       */\n\n      const selection = aggregation[rootKey]['value'].split('.');\n      /**\n       * For each category:name pair (e.g. subtype:article) in the path\n       * add it to the request if not already present\n       */\n\n      for (let i = 0, j = 1; j <= selection.length; i += 2, j += 2) {\n        const key = selection[i];\n        const value = selection[j];\n        key in getParams ? getParams[key].push(value) : getParams[key] = [value];\n      }\n    });\n  }\n  /**\n   * Return a serialized version of the app state `query` for the API backend.\n   * @param {object} stateQuery the `query` state to serialize\n   */\n\n\n}","map":{"version":3,"sources":["/home/datio/workspace/react-searchkit/src/lib/api/contrib/invenio/InvenioRequestSerializer.js"],"names":["Qs","InvenioRequestSerializer","serialize","stateQuery","queryString","sortBy","sortOrder","page","size","aggregations","getParams","_addAggregations","stringify","arrayFormat","forEach","aggregation","rootKey","Object","keys","selection","split","i","j","length","key","value","push"],"mappings":"AAAA;;;;;;;AAQA,OAAOA,EAAP,MAAe,IAAf;AAEA;;AACA,OAAO,MAAMC,wBAAN,CAA+B;AAAA;AAAA,SA+BpCC,SA/BoC,GA+BxBC,UAAU,IAAI;AAAA,YAEtBC,WAFsB,GAQpBD,UARoB,CAEtBC,WAFsB;AAAA,YAGtBC,MAHsB,GAQpBF,UARoB,CAGtBE,MAHsB;AAAA,YAItBC,SAJsB,GAQpBH,UARoB,CAItBG,SAJsB;AAAA,YAKtBC,IALsB,GAQpBJ,UARoB,CAKtBI,IALsB;AAAA,YAMtBC,IANsB,GAQpBL,UARoB,CAMtBK,IANsB;AAAA,YAOtBC,YAPsB,GAQpBN,UARoB,CAOtBM,YAPsB;AAUxB,YAAMC,SAAS,GAAG,EAAlB;;AACA,UAAIN,WAAW,KAAK,IAApB,EAA0B;AACxBM,QAAAA,SAAS,CAAC,GAAD,CAAT,GAAiBN,WAAjB;AACD;;AACD,UAAIC,MAAM,KAAK,IAAf,EAAqB;AACnBK,QAAAA,SAAS,CAAC,MAAD,CAAT,GAAoBL,MAApB;;AAEA,YAAIC,SAAS,KAAK,IAAlB,EAAwB;AACtBI,UAAAA,SAAS,CAAC,MAAD,CAAT,GAAoBJ,SAAS,KAAK,MAAd,cAA2BD,MAA3B,IAAsCA,MAA1D;AACD;AACF;;AACD,UAAIE,IAAI,GAAG,CAAX,EAAc;AACZG,QAAAA,SAAS,CAAC,MAAD,CAAT,GAAoBH,IAApB;AACD;;AACD,UAAIC,IAAI,GAAG,CAAX,EAAc;AACZE,QAAAA,SAAS,CAAC,MAAD,CAAT,GAAoBF,IAApB;AACD;;AACD,WAAKG,gBAAL,CAAsBD,SAAtB,EAAiCD,YAAjC;;AAEA,aAAOT,EAAE,CAACY,SAAH,CAAaF,SAAb,EAAwB;AAAEG,QAAAA,WAAW,EAAE;AAAf,OAAxB,CAAP;AACD,KA7DmC;AAAA;;AACpCF,EAAAA,gBAAgB,CAACD,SAAD,EAAYD,YAAZ,EAA0B;AACxCA,IAAAA,YAAY,CAACK,OAAb,CAAqBC,WAAW,IAAI;AAClC,YAAMC,OAAO,GAAGC,MAAM,CAACC,IAAP,CAAYH,WAAZ,EAAyB,CAAzB,CAAhB;AAEA;;;;;;;AAMA,YAAMI,SAAS,GAAGJ,WAAW,CAACC,OAAD,CAAX,CAAqB,OAArB,EAA8BI,KAA9B,CAAoC,GAApC,CAAlB;AAEA;;;;;AAIA,WAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG,CAApB,EAAuBA,CAAC,IAAIH,SAAS,CAACI,MAAtC,EAA8CF,CAAC,IAAI,CAAL,EAAQC,CAAC,IAAI,CAA3D,EAA8D;AAC5D,cAAME,GAAG,GAAGL,SAAS,CAACE,CAAD,CAArB;AACA,cAAMI,KAAK,GAAGN,SAAS,CAACG,CAAD,CAAvB;AACAE,QAAAA,GAAG,IAAId,SAAP,GACIA,SAAS,CAACc,GAAD,CAAT,CAAeE,IAAf,CAAoBD,KAApB,CADJ,GAEKf,SAAS,CAACc,GAAD,CAAT,GAAiB,CAACC,KAAD,CAFtB;AAGD;AACF,KAtBD;AAuBD;AAED;;;;;;AA3BoC","sourcesContent":["/*\n * This file is part of React-SearchKit.\n * Copyright (C) 2019 CERN.\n *\n * React-SearchKit is free software; you can redistribute it and/or modify it\n * under the terms of the MIT License; see LICENSE file for more details.\n */\n\nimport Qs from 'qs';\n\n/** Default backend request serializer */\nexport class InvenioRequestSerializer {\n  _addAggregations(getParams, aggregations) {\n    aggregations.forEach(aggregation => {\n      const rootKey = Object.keys(aggregation)[0];\n\n      /**\n       * The selection represent any one of the aggregation values clicked at any level of depth.\n       * Its value is the whole path e.g. for Type -> Publication -> (Subtype)Article\n       * the value will be type.publication.subtype.article from which the array will be created\n       * @type {string[]}\n       */\n      const selection = aggregation[rootKey]['value'].split('.');\n\n      /**\n       * For each category:name pair (e.g. subtype:article) in the path\n       * add it to the request if not already present\n       */\n      for (let i = 0, j = 1; j <= selection.length; i += 2, j += 2) {\n        const key = selection[i];\n        const value = selection[j];\n        key in getParams\n          ? getParams[key].push(value)\n          : (getParams[key] = [value]);\n      }\n    });\n  }\n\n  /**\n   * Return a serialized version of the app state `query` for the API backend.\n   * @param {object} stateQuery the `query` state to serialize\n   */\n  serialize = stateQuery => {\n    const {\n      queryString,\n      sortBy,\n      sortOrder,\n      page,\n      size,\n      aggregations,\n    } = stateQuery;\n\n    const getParams = {};\n    if (queryString !== null) {\n      getParams['q'] = queryString;\n    }\n    if (sortBy !== null) {\n      getParams['sort'] = sortBy;\n\n      if (sortOrder !== null) {\n        getParams['sort'] = sortOrder === 'desc' ? `-${sortBy}` : sortBy;\n      }\n    }\n    if (page > 0) {\n      getParams['page'] = page;\n    }\n    if (size > 0) {\n      getParams['size'] = size;\n    }\n    this._addAggregations(getParams, aggregations);\n\n    return Qs.stringify(getParams, { arrayFormat: 'repeat' });\n  };\n}\n"]},"metadata":{},"sourceType":"module"}