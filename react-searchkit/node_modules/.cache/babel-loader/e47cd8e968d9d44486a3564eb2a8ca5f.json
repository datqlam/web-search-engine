{"ast":null,"code":"/*\n * This file is part of React-SearchKit.\n * Copyright (C) 2019 CERN.\n *\n * React-SearchKit is free software; you can redistribute it and/or modify it\n * under the terms of the MIT License; see LICENSE file for more details.\n */\nimport Qs from 'qs';\n/** Default backend request serializer */\n\nexport class InvenioRequestSerializer {\n  constructor() {\n    this.serialize = stateQuery => {\n      // const {\n      //   queryString,\n      //   sortBy,\n      //   sortOrder,\n      //   page,\n      //   size,\n      //   aggregations,\n      // } = stateQuery;\n      // const getParams = {};\n      // if (queryString !== null) {\n      //   getParams['q'] = queryString;\n      // }\n      // if (sortBy !== null) {\n      //   getParams['sort'] = sortBy;\n      //   if (sortOrder !== null) {\n      //     getParams['sort'] = sortOrder === 'desc' ? `-${sortBy}` : sortBy;\n      //   }\n      // }\n      // if (page > 0) {\n      //   getParams['page'] = page;\n      // }\n      // if (size > 0) {\n      //   getParams['size'] = size;\n      // }\n      // this._addAggregations(getParams, aggregations);\n      return Qs.stringify(getParams, {\n        arrayFormat: 'repeat'\n      });\n    };\n  }\n\n}","map":{"version":3,"sources":["/home/datio/workspace/react-searchkit/src/lib/api/contrib/invenio/InvenioRequestSerializer.js"],"names":["Qs","InvenioRequestSerializer","serialize","stateQuery","stringify","getParams","arrayFormat"],"mappings":"AAAA;;;;;;;AAQA,OAAOA,EAAP,MAAe,IAAf;AAEA;;AACA,OAAO,MAAMC,wBAAN,CAA+B;AAAA;AAAA,SA+BpCC,SA/BoC,GA+BxBC,UAAU,IAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,aAAOH,EAAE,CAACI,SAAH,CAAaC,SAAb,EAAwB;AAAEC,QAAAA,WAAW,EAAE;AAAf,OAAxB,CAAP;AACD,KA7DmC;AAAA;;AAAA","sourcesContent":["/*\n * This file is part of React-SearchKit.\n * Copyright (C) 2019 CERN.\n *\n * React-SearchKit is free software; you can redistribute it and/or modify it\n * under the terms of the MIT License; see LICENSE file for more details.\n */\n\nimport Qs from 'qs';\n\n/** Default backend request serializer */\nexport class InvenioRequestSerializer {\n  // _addAggregations(getParams, aggregations) {\n  //   aggregations.forEach(aggregation => {\n  //     const rootKey = Object.keys(aggregation)[0];\n\n  //     /**\n  //      * The selection represent any one of the aggregation values clicked at any level of depth.\n  //      * Its value is the whole path e.g. for Type -> Publication -> (Subtype)Article\n  //      * the value will be type.publication.subtype.article from which the array will be created\n  //      * @type {string[]}\n  //      */\n  //     const selection = aggregation[rootKey]['value'].split('.');\n\n  //     /**\n  //      * For each category:name pair (e.g. subtype:article) in the path\n  //      * add it to the request if not already present\n  //      */\n  //     for (let i = 0, j = 1; j <= selection.length; i += 2, j += 2) {\n  //       const key = selection[i];\n  //       const value = selection[j];\n  //       key in getParams\n  //         ? getParams[key].push(value)\n  //         : (getParams[key] = [value]);\n  //     }\n  //   });\n  // }\n\n  /**\n   * Return a serialized version of the app state `query` for the API backend.\n   * @param {object} stateQuery the `query` state to serialize\n   */\n  serialize = stateQuery => {\n    // const {\n    //   queryString,\n    //   sortBy,\n    //   sortOrder,\n    //   page,\n    //   size,\n    //   aggregations,\n    // } = stateQuery;\n\n    // const getParams = {};\n    // if (queryString !== null) {\n    //   getParams['q'] = queryString;\n    // }\n    // if (sortBy !== null) {\n    //   getParams['sort'] = sortBy;\n\n    //   if (sortOrder !== null) {\n    //     getParams['sort'] = sortOrder === 'desc' ? `-${sortBy}` : sortBy;\n    //   }\n    // }\n    // if (page > 0) {\n    //   getParams['page'] = page;\n    // }\n    // if (size > 0) {\n    //   getParams['size'] = size;\n    // }\n    // this._addAggregations(getParams, aggregations);\n\n    return Qs.stringify(getParams, { arrayFormat: 'repeat' });\n  };\n}\n"]},"metadata":{},"sourceType":"module"}