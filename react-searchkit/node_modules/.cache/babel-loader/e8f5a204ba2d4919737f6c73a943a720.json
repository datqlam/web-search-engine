{"ast":null,"code":"/*\n * This file is part of React-SearchKit.\n * Copyright (C) 2018-2019 CERN.\n *\n * React-SearchKit is free software; you can redistribute it and/or modify it\n * under the terms of the MIT License; see LICENSE file for more details.\n */\nimport Qs from 'qs';\nimport _isNaN from 'lodash/isNaN';\nimport _isNil from 'lodash/isNil';\nimport _cloneDeep from 'lodash/cloneDeep';\n\nconst pushHistory = query => {\n  if (window.history.pushState) {\n    window.history.pushState({\n      path: query\n    }, '', query);\n  }\n};\n\nconst replaceHistory = query => {\n  if (window.history.replaceState) {\n    window.history.replaceState({\n      path: query\n    }, '', query);\n  }\n};\n/** Default URL parser implementation */\n\n\nclass UrlParser {\n  constructor() {\n    this._sanitizeParamValue = value => {\n      let parsedValue = parseInt(value);\n\n      if (_isNaN(parsedValue)) {\n        try {\n          const _value = JSON.parse(value);\n\n          if (!_isNil(_value)) {\n            parsedValue = _value;\n          }\n        } catch (e) {\n          if (value !== 'undefined') {\n            parsedValue = value;\n          } else {\n            console.error(\"Cannot parse value \".concat(value, \".\"));\n          }\n        }\n      }\n\n      return parsedValue;\n    };\n\n    this.parse = (queryString = '') => {\n      const parsedParams = Qs.parse(queryString, {\n        ignoreQueryPrefix: true\n      });\n      const params = {};\n      Object.entries(parsedParams).forEach(entry => {\n        const key = entry[0];\n        const value = entry[1];\n        params[key] = this._sanitizeParamValue(value);\n      });\n      return params;\n    };\n  }\n\n}\n/** Default implementation for a param validator class */\n\n\nexport class ParamValidator {\n  constructor() {\n    this.isValid = (key, value) => true;\n  }\n\n}\n/** Object responsible to update the URL query string and parse it to update the app state */\n\nexport class UrlQueryStringHandler {\n  constructor(config = {}) {\n    this._transformQueryToUrlParams = queryState => {\n      const params = {};\n      Object.keys(queryState).filter(stateKey => stateKey in this.urlParamsMapping).filter(stateKey => {\n        // filter out negative or null values\n        if ((stateKey === 'page' || stateKey === 'size') && queryState[stateKey] <= 0) {\n          return false;\n        }\n\n        return queryState[stateKey] !== null;\n      }).forEach(stateKey => {\n        const paramKey = this.urlParamsMapping[stateKey];\n        params[paramKey] = queryState[stateKey];\n      }); // will omit undefined and null values from the query\n\n      return Qs.stringify(params, {\n        addQueryPrefix: true,\n        skipNulls: true\n      });\n    };\n\n    this._mergeParamsIntoState = (params, queryState) => {\n      const _queryState = _cloneDeep(queryState);\n\n      Object.keys(params).forEach(paramKey => {\n        const stateKey = this.fromParamsMapping[paramKey];\n\n        if (this.paramValidator.isValid(paramKey, params[paramKey])) {\n          if (stateKey in _queryState) {\n            _queryState[stateKey] = params[paramKey];\n          }\n        }\n      });\n      return _queryState;\n    };\n\n    this.get = queryState => {\n      const currentParams = this.urlParser.parse(window.location.search);\n\n      const newQueryState = this._mergeParamsIntoState(currentParams, queryState);\n\n      const newUrlParams = this._transformQueryToUrlParams(newQueryState);\n\n      replaceHistory(newUrlParams);\n      return newQueryState;\n    };\n\n    this.set = stateQuery => {\n      const newUrlParams = this._transformQueryToUrlParams(stateQuery);\n\n      this.withHistory ? pushHistory(newUrlParams) : replaceHistory(newUrlParams);\n    };\n\n    this.urlParamsMapping = config.urlParamsMapping || {\n      queryString: 'q',\n      sortBy: 'sort',\n      sortOrder: 'order',\n      page: 'p',\n      size: 's',\n      layout: 'l',\n      aggregations: 'aggr'\n    };\n    this.withHistory = config.withHistory || true;\n    this.paramValidator = config.paramValidator || new ParamValidator();\n    this.urlParser = config.urlParser || new UrlParser(); // build the serializer from URL params to state by flipping the url params serializer\n\n    this.fromParamsMapping = {};\n    Object.keys(this.urlParamsMapping).forEach(stateKey => {\n      this.fromParamsMapping[this.urlParamsMapping[stateKey]] = stateKey;\n    });\n  }\n\n}","map":{"version":3,"sources":["/home/datio/workspace/react-searchkit/src/lib/api/UrlQueryStringHandler.js"],"names":["Qs","_isNaN","_isNil","_cloneDeep","pushHistory","query","window","history","pushState","path","replaceHistory","replaceState","UrlParser","_sanitizeParamValue","value","parsedValue","parseInt","_value","JSON","parse","e","console","error","queryString","parsedParams","ignoreQueryPrefix","params","Object","entries","forEach","entry","key","ParamValidator","isValid","UrlQueryStringHandler","constructor","config","_transformQueryToUrlParams","queryState","keys","filter","stateKey","urlParamsMapping","paramKey","stringify","addQueryPrefix","skipNulls","_mergeParamsIntoState","_queryState","fromParamsMapping","paramValidator","get","currentParams","urlParser","location","search","newQueryState","newUrlParams","set","stateQuery","withHistory","sortBy","sortOrder","page","size","layout","aggregations"],"mappings":"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","sourcesContent":["/*\n * This file is part of React-SearchKit.\n * Copyright (C) 2018-2019 CERN.\n *\n * React-SearchKit is free software; you can redistribute it and/or modify it\n * under the terms of the MIT License; see LICENSE file for more details.\n */\n\nimport Qs from 'qs';\nimport _isNaN from 'lodash/isNaN';\nimport _isNil from 'lodash/isNil';\nimport _cloneDeep from 'lodash/cloneDeep';\n\nconst pushHistory = query => {\n  if (window.history.pushState) {\n    window.history.pushState({ path: query }, '', query);\n  }\n};\n\nconst replaceHistory = query => {\n  if (window.history.replaceState) {\n    window.history.replaceState({ path: query }, '', query);\n  }\n};\n\n/** Default URL parser implementation */\nclass UrlParser {\n  _sanitizeParamValue = value => {\n    let parsedValue = parseInt(value);\n    if (_isNaN(parsedValue)) {\n      try {\n        const _value = JSON.parse(value);\n        if (!_isNil(_value)) {\n          parsedValue = _value;\n        }\n      } catch (e) {\n        if (value !== 'undefined') {\n          parsedValue = value;\n        } else {\n          console.error(`Cannot parse value ${value}.`);\n        }\n      }\n    }\n    return parsedValue;\n  };\n\n  /**\n   * Parse the URL query string and return an object with all the params.\n   * @param {string} queryString the query string to parse\n   */\n  parse = (queryString = '') => {\n    const parsedParams = Qs.parse(queryString, { ignoreQueryPrefix: true });\n    const params = {};\n    Object.entries(parsedParams).forEach(entry => {\n      const key = entry[0];\n      const value = entry[1];\n      params[key] = this._sanitizeParamValue(value);\n    });\n    return params;\n  };\n}\n\n/** Default implementation for a param validator class */\nexport class ParamValidator {\n  /**\n   * Return true if the param value is valid, false otherwise\n   * @param {object} queryState the `query` state\n   * @param {boolean} updateUrlQueryString a flag to push the new updated version of `query` state to the URL query string\n   */\n  isValid = (key, value) => true;\n}\n\n/** Object responsible to update the URL query string and parse it to update the app state */\nexport class UrlQueryStringHandler {\n  constructor(config = {}) {\n    this.urlParamsMapping = config.urlParamsMapping || {\n      queryString: 'q',\n      sortBy: 'sort',\n      sortOrder: 'order',\n      page: 'p',\n      size: 's',\n      layout: 'l',\n      aggregations: 'aggr',\n    };\n\n    this.withHistory = config.withHistory || true;\n    this.paramValidator = config.paramValidator || new ParamValidator();\n    this.urlParser = config.urlParser || new UrlParser();\n\n    // build the serializer from URL params to state by flipping the url params serializer\n    this.fromParamsMapping = {};\n    Object.keys(this.urlParamsMapping).forEach(stateKey => {\n      this.fromParamsMapping[this.urlParamsMapping[stateKey]] = stateKey;\n    });\n  }\n\n  _transformQueryToUrlParams = queryState => {\n    const params = {};\n    Object.keys(queryState)\n      .filter(stateKey => stateKey in this.urlParamsMapping)\n      .filter(stateKey => {\n        // filter out negative or null values\n        if (\n          (stateKey === 'page' || stateKey === 'size') &&\n          queryState[stateKey] <= 0\n        ) {\n          return false;\n        }\n        return queryState[stateKey] !== null;\n      })\n      .forEach(stateKey => {\n        const paramKey = this.urlParamsMapping[stateKey];\n        params[paramKey] = queryState[stateKey];\n      });\n\n    // will omit undefined and null values from the query\n    return Qs.stringify(params, {\n      addQueryPrefix: true,\n      skipNulls: true,\n    });\n  };\n\n  _mergeParamsIntoState = (params, queryState) => {\n    const _queryState = _cloneDeep(queryState);\n    Object.keys(params).forEach(paramKey => {\n      const stateKey = this.fromParamsMapping[paramKey];\n      if (this.paramValidator.isValid(paramKey, params[paramKey])) {\n        if (stateKey in _queryState) {\n          _queryState[stateKey] = params[paramKey];\n        }\n      }\n    });\n    return _queryState;\n  };\n\n  /**\n   * Return a new version of the given `query` state with updated values parsed from the URL query string.\n   * @param {object} queryState the `query` state\n   */\n  get = queryState => {\n    const currentParams = this.urlParser.parse(window.location.search);\n    const newQueryState = this._mergeParamsIntoState(currentParams, queryState);\n    const newUrlParams = this._transformQueryToUrlParams(newQueryState);\n    replaceHistory(newUrlParams);\n    return newQueryState;\n  };\n\n  /**\n   * Update the URL query string parameters from the given `query` state\n   * @param {object} stateQuery the `query` state\n   */\n  set = stateQuery => {\n    const newUrlParams = this._transformQueryToUrlParams(stateQuery);\n    this.withHistory ? pushHistory(newUrlParams) : replaceHistory(newUrlParams);\n  };\n}\n"]},"metadata":{},"sourceType":"module"}