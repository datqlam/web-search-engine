{"ast":null,"code":"/*\n * This file is part of React-SearchKit.\n * Copyright (C) 2018 CERN.\n *\n * React-SearchKit is free software; you can redistribute it and/or modify it\n * under the terms of the MIT License; see LICENSE file for more details.\n */\nimport Qs from 'qs';\n/**\n * Return true if the first string starts and contains the second.\n * @param {string} first a string\n * @param {string} second a string\n */\n\nfunction startsWith(first, second) {\n  return first.indexOf(second) === 0;\n}\n/**\n * Return true if the query is not an exact match with one of the previous states and the query has a value.\n * This covers the case when the user re-selects one aggregation that was previously selected to remove it, or\n * when he selects a root aggregation (no value).\n * @param {string} query The user query\n * @param {boolean} isExactMatch true if the query matches with one of the previous states\n */\n\n\nfunction shouldBeAddedToState(query, isExactMatch) {\n  const firstKey = Object.keys(query)[0];\n  return !isExactMatch && query[firstKey]['value'];\n}\n\nexport const updateQueryAggregation = (query, state) => {\n  if (!query) return;\n  const strQuery = Qs.stringify(query);\n  const strStates = state.map(stateObjQuery => Qs.stringify(stateObjQuery));\n  let isExactMatch = false;\n  const filtered = [];\n  strStates.forEach(strState => {\n    const queryMatchState = startsWith(strState, strQuery);\n    const stateMatchQuery = startsWith(strQuery, strState); // check if it the state is exactly the query\n\n    if (!isExactMatch) {\n      isExactMatch = queryMatchState && stateMatchQuery;\n    } // keep the current state only if there is no match with the query\n\n\n    if (!queryMatchState && !stateMatchQuery) {\n      filtered.push(strState);\n    }\n  });\n\n  if (shouldBeAddedToState(query, isExactMatch)) {\n    filtered.push(strQuery);\n  }\n\n  return filtered.map(stateStrQuery => Qs.parse(stateStrQuery));\n};","map":{"version":3,"sources":["/home/datio/workspace/react-searchkit/src/lib/state/selectors/query.js"],"names":["Qs","startsWith","first","second","indexOf","shouldBeAddedToState","query","isExactMatch","firstKey","Object","keys","updateQueryAggregation","state","strQuery","stringify","strStates","map","stateObjQuery","filtered","forEach","strState","queryMatchState","stateMatchQuery","push","stateStrQuery","parse"],"mappings":"AAAA;;;;;;;AAQA,OAAOA,EAAP,MAAe,IAAf;AAEA;;;;;;AAKA,SAASC,UAAT,CAAoBC,KAApB,EAA2BC,MAA3B,EAAmC;AACjC,SAAOD,KAAK,CAACE,OAAN,CAAcD,MAAd,MAA0B,CAAjC;AACD;AAED;;;;;;;;;AAOA,SAASE,oBAAT,CAA8BC,KAA9B,EAAqCC,YAArC,EAAmD;AACjD,QAAMC,QAAQ,GAAGC,MAAM,CAACC,IAAP,CAAYJ,KAAZ,EAAmB,CAAnB,CAAjB;AACA,SAAO,CAACC,YAAD,IAAiBD,KAAK,CAACE,QAAD,CAAL,CAAgB,OAAhB,CAAxB;AACD;;AAED,OAAO,MAAMG,sBAAsB,GAAG,CAACL,KAAD,EAAQM,KAAR,KAAkB;AACtD,MAAI,CAACN,KAAL,EAAY;AACZ,QAAMO,QAAQ,GAAGb,EAAE,CAACc,SAAH,CAAaR,KAAb,CAAjB;AAEA,QAAMS,SAAS,GAAGH,KAAK,CAACI,GAAN,CAAUC,aAAa,IAAIjB,EAAE,CAACc,SAAH,CAAaG,aAAb,CAA3B,CAAlB;AAEA,MAAIV,YAAY,GAAG,KAAnB;AACA,QAAMW,QAAQ,GAAG,EAAjB;AACAH,EAAAA,SAAS,CAACI,OAAV,CAAkBC,QAAQ,IAAI;AAC5B,UAAMC,eAAe,GAAGpB,UAAU,CAACmB,QAAD,EAAWP,QAAX,CAAlC;AACA,UAAMS,eAAe,GAAGrB,UAAU,CAACY,QAAD,EAAWO,QAAX,CAAlC,CAF4B,CAI5B;;AACA,QAAI,CAACb,YAAL,EAAmB;AACjBA,MAAAA,YAAY,GAAGc,eAAe,IAAIC,eAAlC;AACD,KAP2B,CAS5B;;;AACA,QAAI,CAACD,eAAD,IAAoB,CAACC,eAAzB,EAA0C;AACxCJ,MAAAA,QAAQ,CAACK,IAAT,CAAcH,QAAd;AACD;AACF,GAbD;;AAeA,MAAIf,oBAAoB,CAACC,KAAD,EAAQC,YAAR,CAAxB,EAA+C;AAC7CW,IAAAA,QAAQ,CAACK,IAAT,CAAcV,QAAd;AACD;;AAED,SAAOK,QAAQ,CAACF,GAAT,CAAaQ,aAAa,IAAIxB,EAAE,CAACyB,KAAH,CAASD,aAAT,CAA9B,CAAP;AACD,CA5BM","sourcesContent":["/*\n * This file is part of React-SearchKit.\n * Copyright (C) 2018 CERN.\n *\n * React-SearchKit is free software; you can redistribute it and/or modify it\n * under the terms of the MIT License; see LICENSE file for more details.\n */\n\nimport Qs from 'qs';\n\n/**\n * Return true if the first string starts and contains the second.\n * @param {string} first a string\n * @param {string} second a string\n */\nfunction startsWith(first, second) {\n  return first.indexOf(second) === 0;\n}\n\n/**\n * Return true if the query is not an exact match with one of the previous states and the query has a value.\n * This covers the case when the user re-selects one aggregation that was previously selected to remove it, or\n * when he selects a root aggregation (no value).\n * @param {string} query The user query\n * @param {boolean} isExactMatch true if the query matches with one of the previous states\n */\nfunction shouldBeAddedToState(query, isExactMatch) {\n  const firstKey = Object.keys(query)[0];\n  return !isExactMatch && query[firstKey]['value'];\n}\n\nexport const updateQueryAggregation = (query, state) => {\n  if (!query) return;\n  const strQuery = Qs.stringify(query);\n\n  const strStates = state.map(stateObjQuery => Qs.stringify(stateObjQuery));\n\n  let isExactMatch = false;\n  const filtered = [];\n  strStates.forEach(strState => {\n    const queryMatchState = startsWith(strState, strQuery);\n    const stateMatchQuery = startsWith(strQuery, strState);\n\n    // check if it the state is exactly the query\n    if (!isExactMatch) {\n      isExactMatch = queryMatchState && stateMatchQuery;\n    }\n\n    // keep the current state only if there is no match with the query\n    if (!queryMatchState && !stateMatchQuery) {\n      filtered.push(strState);\n    }\n  });\n\n  if (shouldBeAddedToState(query, isExactMatch)) {\n    filtered.push(strQuery);\n  }\n\n  return filtered.map(stateStrQuery => Qs.parse(stateStrQuery));\n};\n"]},"metadata":{},"sourceType":"module"}