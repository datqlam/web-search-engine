{"ast":null,"code":"/*\n * This file is part of React-SearchKit.\n * Copyright (C) 2019 CERN.\n *\n * React-SearchKit is free software; you can redistribute it and/or modify it\n * under the terms of the MIT License; see LICENSE file for more details.\n */\nimport _isPlainObject from 'lodash/isPlainObject';\nimport _find from 'lodash/find';\n/** Default backend response serializer */\n\nexport class InvenioResponseSerializer {\n  constructor() {\n    this.serialize = payload => {\n      return {\n        aggregations: this._serializeAggregations(payload.aggregations || {}),\n        hits: payload.hits.hits,\n        total: payload.hits.total\n      };\n    };\n  }\n\n  _createAggregation(parentKeyName, buckets) {\n    let aggregations = {};\n    buckets.forEach(item => {\n      const nestedField = _find(Object.keys(item), key => _isPlainObject(item[key]) && 'buckets' in item[key] && item[key].buckets.length);\n\n      if (nestedField) {\n        const nestedAggregationPath = [nestedField, 'buckets'];\n\n        const nestedBuckets = this._extractFromPath(item, nestedAggregationPath);\n\n        const newKeyName = ''.concat(parentKeyName, '.', item.key);\n        aggregations[item.key] = this._createAggregation(''.concat(newKeyName, '.', nestedField), nestedBuckets);\n        aggregations[item.key]['key'] = newKeyName;\n        aggregations[item.key]['name'] = item.key;\n        aggregations[item.key]['total'] = item.doc_count;\n        aggregations[item.key]['hasNestedField'] = nestedField;\n      } else {\n        const parentNestedField = parentKeyName.split('.').slice(-1);\n        aggregations[item.key] = {\n          hasNestedField: false,\n          name: item.key,\n          total: item.doc_count,\n          key: ''.concat(parentKeyName, '.', item.key)\n        };\n      }\n    }, this);\n    return aggregations;\n  }\n\n  _extractFromPath(aggregation, pathToExtract) {\n    return pathToExtract.reduce((obj, key) => obj && obj[key] !== 'undefined' ? obj[key] : undefined, aggregation);\n  }\n\n  _serializeAggregations(aggregationsResponse) {\n    const aggregations = {};\n    Object.keys(aggregationsResponse).forEach(aggregationName => {\n      aggregations[aggregationName] = {};\n\n      const mainBuckets = this._extractFromPath(aggregationsResponse[aggregationName], ['buckets']);\n\n      aggregations[aggregationName] = this._createAggregation(aggregationName, mainBuckets);\n    }, this);\n    return aggregations;\n  }\n  /**\n   * Return a serialized version of the API backend response for the app state `results`.\n   * @param {object} payload the backend response payload\n   */\n\n\n}","map":{"version":3,"sources":["/home/datio/workspace/react-searchkit/src/lib/api/contrib/invenio/InvenioResponseSerializer.js"],"names":["_isPlainObject","_find","InvenioResponseSerializer","serialize","payload","aggregations","_serializeAggregations","hits","total","_createAggregation","parentKeyName","buckets","forEach","item","nestedField","Object","keys","key","length","nestedAggregationPath","nestedBuckets","_extractFromPath","newKeyName","concat","doc_count","parentNestedField","split","slice","hasNestedField","name","aggregation","pathToExtract","reduce","obj","undefined","aggregationsResponse","aggregationName","mainBuckets"],"mappings":"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","sourcesContent":["/*\n * This file is part of React-SearchKit.\n * Copyright (C) 2019 CERN.\n *\n * React-SearchKit is free software; you can redistribute it and/or modify it\n * under the terms of the MIT License; see LICENSE file for more details.\n */\n\nimport _isPlainObject from 'lodash/isPlainObject';\nimport _find from 'lodash/find';\n\n/** Default backend response serializer */\nexport class InvenioResponseSerializer {\n  _createAggregation(parentKeyName, buckets) {\n    let aggregations = {};\n\n    buckets.forEach(item => {\n      const nestedField = _find(\n        Object.keys(item),\n        key =>\n          _isPlainObject(item[key]) &&\n          'buckets' in item[key] &&\n          item[key].buckets.length\n      );\n      if (nestedField) {\n        const nestedAggregationPath = [nestedField, 'buckets'];\n        const nestedBuckets = this._extractFromPath(\n          item,\n          nestedAggregationPath\n        );\n        const newKeyName = ''.concat(parentKeyName, '.', item.key);\n        aggregations[item.key] = this._createAggregation(\n          ''.concat(newKeyName, '.', nestedField),\n          nestedBuckets\n        );\n        aggregations[item.key]['key'] = newKeyName;\n        aggregations[item.key]['name'] = item.key;\n        aggregations[item.key]['total'] = item.doc_count;\n        aggregations[item.key]['hasNestedField'] = nestedField;\n      } else {\n        const parentNestedField = parentKeyName.split('.').slice(-1);\n        aggregations[item.key] = {\n          hasNestedField: false,\n          name: item.key,\n          total: item.doc_count,\n          key: ''.concat(parentKeyName, '.', item.key),\n        };\n      }\n    }, this);\n\n    return aggregations;\n  }\n\n  _extractFromPath(aggregation, pathToExtract) {\n    return pathToExtract.reduce(\n      (obj, key) => (obj && obj[key] !== 'undefined' ? obj[key] : undefined),\n      aggregation\n    );\n  }\n\n  _serializeAggregations(aggregationsResponse) {\n    const aggregations = {};\n\n    Object.keys(aggregationsResponse).forEach(aggregationName => {\n      aggregations[aggregationName] = {};\n      const mainBuckets = this._extractFromPath(\n        aggregationsResponse[aggregationName],\n        ['buckets']\n      );\n      aggregations[aggregationName] = this._createAggregation(\n        aggregationName,\n        mainBuckets\n      );\n    }, this);\n\n    return aggregations;\n  }\n\n  /**\n   * Return a serialized version of the API backend response for the app state `results`.\n   * @param {object} payload the backend response payload\n   */\n  serialize = payload => {\n    return {\n      aggregations: this._serializeAggregations(payload.aggregations || {}),\n      hits: payload.hits.hits,\n      total: payload.hits.total,\n    };\n  };\n}\n"]},"metadata":{},"sourceType":"module"}